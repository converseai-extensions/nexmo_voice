/**
 * @file converseai_channels.js
 * @author scott@converse.ai
 *
 * Generated by the converse-cli tool for use with the Converse AI
 * Plugins SDK. https://developers.converse.ai/
 */

'use strict';

const Status = require('@converseai/plugins-sdk').Status;
const InboundResponse = require('@converseai/plugins-sdk').Payloads.Channel.Sync.InboundResponse;
const OutboundResponse = require('@converseai/plugins-sdk').Payloads.Channel.Sync.OutboundResponse;
const InboundOutput = require('@converseai/plugins-sdk').Payloads.Channel.Sync.InboundOutput;
const Message = require('@converseai/plugins-sdk').Payloads.Channel.Sync.Message;
const HttpResponse = require('@converseai/plugins-sdk').Payloads.HttpResponse;
const ErrorResponse = require('@converseai/plugins-sdk').Payloads.ErrorResponse;
const Utils = require('./lib/utils.js');

const AsyncInboundResponse = require('@converseai/plugins-sdk').Payloads.Channel.Async.InboundResponse;

var onMessageInbound = function(app, body) {

  var action = body.payload.queryParam.action.data[0];

  var registrationData = body.payload.registrationData;

  switch (action) {
    case "sms":

      var inbound = getSMSInboundPayloadData(body.payload);

      var output = new InboundOutput();

      output.setUserId(inbound.data.from);
      output.setThreadId("sms_" + inbound.data.to);
      output.setData(inbound.data);
      output.setRuntimeCTX(inbound.runtime);
      output.setSync(false);
      output.setUserInfo({
        email: "nexmo-" + inbound.data.from + "@cnv.ai",
        firstName: inbound.data.from,
        phoneNumber: inbound.data.from
      });

      var textMessage = new Message.Text();
      textMessage.setText(inbound.runtime.message);
      output.setMessage(textMessage);

      var response = new AsyncInboundResponse();
      response.addOutput(output);
      response.setHTTPResponse({
        httpStatus: 200,
        body: "ok",
      });
      app.send(Status.SUCCESS, response);
      break;
    case "number":

      var response = new OutboundResponse();
      response.setHTTPResponse({
        httpStatus: 200,
        body: "ok",
      });

      app.send(Status.SUCCESS, response);
      break;
    case "outbound":

      var inbound = getInboundPayloadData(body.payload, false);

      var output = new InboundOutput();

      if (inbound.runtime.direction != "outbound") {
        var temp = inbound.data.from;
        inbound.data.from = inbound.data.to;
        inbound.data.to = temp;
        inbound.runtime.direction = "outbound";
      }

      output.setUserId(inbound.data.from);
      output.setThreadId(inbound.data.to);
      output.setData(inbound.data);
      output.setRuntimeCTX(inbound.runtime);
      output.setSync(true);
      output.setUserInfo({
        email: "nexmo-" + inbound.data.from + "@cnv.ai",
        firstName: inbound.data.from,
        phoneNumber: inbound.data.from
      });

      var conversationMessage = new Message.Conversation();
      conversationMessage.setIntent(inbound.runtime.intent, true);
      conversationMessage.setEntityData(inbound.runtime.entities);
      output.setMessage(conversationMessage);

      var response = new InboundResponse();
      response.addOutput(output);
      app.send(Status.SUCCESS, response);

      break;
    case "inbound":

      var inbound = getInboundPayloadData(body.payload, true);
      if (!inbound || !inbound.runtime.intent) {

        // Not setup correctly, just fail
        var response = new OutboundResponse();
        response.setHTTPResponse({
          httpStatus: 200,
          body: "ok",
        });

        app.send(Status.SUCCESS, response);
        return;
      }

      var output = new InboundOutput();

      output.setUserId(inbound.data.from);
      output.setThreadId(inbound.data.to);
      output.setData(inbound.data);
      output.setRuntimeCTX(inbound.runtime);
      output.setSync(true);
      output.setUserInfo({
        email: "nexmo-" + inbound.data.from + "@cnv.ai",
        firstName: inbound.data.from,
        phoneNumber: inbound.data.from
      });

      var conversationMessage = new Message.Conversation();

      conversationMessage.setIntent(inbound.runtime.intent, true);
      conversationMessage.setEntityData(inbound.runtime.entities);

      output.setMessage(conversationMessage);

      var response = new InboundResponse();

      response.addOutput(output);

      app.send(Status.SUCCESS, response);

      break;
    case "response":
      var inbound = getInboundPayloadData(body.payload, false);

      var output = new InboundOutput();

      output.setUserId(inbound.data.from);
      output.setThreadId(inbound.data.to);
      output.setData(inbound.data);
      output.setRuntimeCTX(inbound.runtime);
      output.setSync(true);
      output.setUserInfo({
        email: "nexmo-" + inbound.data.from + "@cnv.ai",
        firstName: inbound.data.from,
        phoneNumber: inbound.data.from
      });

      var textMessage = new Message.Text();
      textMessage.setText(inbound.runtime.dtmf);
      output.setMessage(textMessage);

      var response = new InboundResponse();

      response.addOutput(output);

      app.send(Status.SUCCESS, response);

      break;
    case "recording":

      var inbound = getInboundPayloadData(body.payload, false);

      var conversationUUID = inbound.runtime.conversationUUID;
      var bodyData = inbound.runtime.bodyData;

      if (conversationUUID && bodyData) {

        inbound.runtime.recording = true;

        var output = new InboundOutput();

        output.setUserId(inbound.data.from);
        output.setThreadId(inbound.data.to);
        output.setData(inbound.data);
        output.setRuntimeCTX(inbound.runtime);
        output.setSync(true);
        output.setUserInfo({
          email: "nexmo-" + inbound.data.from + "@cnv.ai",
          firstName: inbound.data.from,
          phoneNumber: inbound.data.from
        });

        var conversationMessage = new Message.Conversation();
        conversationMessage.setIntent(conversationUUID, false);
        conversationMessage.setEntityData(null);
        output.setMessage(conversationMessage);

        var response = new AsyncInboundResponse();
        response.addOutput(output);
        response.setHTTPResponse({
          httpStatus: 200,
          body: "ok",
        });
        app.send(Status.SUCCESS, response);
      }

      break;
    case "fallback":

      if (body.payload.bodyData && body.payload.bodyData.status) {
        var eventType = body.payload.bodyData.status;
        if (eventType == "timeout" ||
          eventType == "failed" ||
          eventType == "rejected" ||
          eventType == "unanswered" ||
          eventType == "busy") {

          var inbound = getInboundPayloadData(body.payload, false);
          if (inbound.runtime.intent) {

            var output = new InboundOutput();

            output.setUserId(inbound.data.from);
            output.setThreadId(inbound.data.to);
            output.setData(inbound.data);
            output.setRuntimeCTX(inbound.runtime);
            output.setSync(true);
            output.setUserInfo({
              email: "nexmo-" + inbound.data.from + "@cnv.ai",
              firstName: inbound.data.from,
              phoneNumber: inbound.data.from
            });

            var conversationMessage = new Message.Conversation();

            conversationMessage.setIntent(inbound.runtime.intent, true);
            conversationMessage.setEntityData(inbound.runtime.entities);
            output.setMessage(conversationMessage);

            var response = new InboundResponse();

            response.addOutput(output);

            app.send(Status.SUCCESS, response);

            break;
          }
        }
      }
      handleEventInbound(app, body);
      break;
    case "event":
      handleEventInbound(app, body);
      break;
    case "conference":

      // if event is complete then we delete the conference local setData
      // if event has recording url we invoke setIntent
      // if event has status, including complete, we call handleEventInbound(app, body);
      var inbound = getInboundPayloadData(body.payload, false);

      if (body.payload.bodyData && body.payload.bodyData.status) {
        var eventType = body.payload.bodyData.status;

        console.log("received event status " + eventType + " on conference callback");

        // If we get any of these states, we delete the conference call local data
        switch (eventType) {
          case "completed":
            //case "timeout":
            //case "failed":
            //case "rejected":
            //case "cancelled":
            deleteConferenceCallLocalData(body, inbound);
            break;
        }

        // Regardless if we handle something specific for conference, we need to call normal event inbound
        handleEventInbound(app, body);
      } else {

        // We would receive the conference recoding_url here

        var bodyData = inbound.runtime.bodyData;

        if (bodyData && bodyData.recording_url) {

          // We are getting the recoding, lets delete the conference call local setData
          deleteConferenceCallLocalData(body, inbound);

          var format = inbound.runtime.recordingFormat;
          if (!format) {
            format = "mp3";
          }

          Utils.getPublicRecordingDetails(body, bodyData, format, function(ok, publicRecoding) {
            if (!ok) {
              console.error(publicRecoding);
              app.fail(publicRecoding);
              return;
            }

            inbound.runtime.recording = true;

            var output = new InboundOutput();

            output.setUserId(inbound.data.from);
            output.setThreadId(inbound.data.to);
            output.setData(inbound.data);
            output.setRuntimeCTX(inbound.runtime);
            output.setSync(true);
            output.setUserInfo({
              email: "nexmo-" + inbound.data.from + "@cnv.ai",
              firstName: inbound.data.from,
              phoneNumber: inbound.data.from
            });

            var conversationMessage = new Message.Conversation();
            conversationMessage.setIntent(inbound.runtime.intent, true);
            conversationMessage.setEntityData(inbound.runtime.entities);
            conversationMessage.setRuntimeCTX(publicRecoding);
            output.setMessage(conversationMessage);

            var response = new AsyncInboundResponse();
            response.addOutput(output);
            response.setHTTPResponse({
              httpStatus: 200,
              body: "ok",
            });
            app.send(Status.SUCCESS, response);

          });
        } else {

          var response = new OutboundResponse();
          response.setHTTPResponse({
            httpStatus: 200,
            body: "ok",
          });

          app.send(Status.SUCCESS, response);
        }
      }
      break;
    default:
      console.error("onMessageInbound unknown action '" + action + "' " + JSON.stringify(body.payload));
      var response = new OutboundResponse();
      response.setHTTPResponse({
        httpStatus: 200,
        body: "ok",
      });

      app.send(Status.SUCCESS, response);
      break;
  }

}

var onMessageOutbound = function(app, body) {

  var payload = body.payload;

  var registrationData = payload.registrationData;
  var callbackUri = registrationData.callback_uri;

  var channelSetting = payload.channelSetting;

  var userId = channelSetting.userId;
  var threadId = channelSetting.threadId;

  if (threadId.startsWith("sms_")) {

    threadId = threadId.replace("sms_", "");

    var message = payload.channelMessage.text;
    if (!message) {
      message = JSON.stringify(payload.channelMessage.media);
    }

    Utils.sendSMS(registrationData, body.caller, userId, threadId, message, function(ok, data) {
      if (!ok) {
        console.error(data);
        app.fail(data);
        return;
      }

      app.send(Status.SUCCESS);
    });
    return;
  }

  var direction = "inbound";
  if (channelSetting.runtimeCTX && channelSetting.runtimeCTX.direction) {
    direction = channelSetting.runtimeCTX.direction;
  }

  var ncco = [];
  if (channelSetting.runtimeCTX.ncco) {
    ncco = channelSetting.runtimeCTX.ncco;
  }

  if (payload.channelMessage.media) {

    var media = payload.channelMessage.media.entity.ncco;
    if (media) {
      for (var i = 0; i < media.length; i++) {
        ncco.push(media[i]);
      }
    }

  } else if (payload.channelMessage.text) {

    var msgContext = payload.msgContext;

    var options = Utils.getOutboundOptions(threadId, registrationData, null);

    if (msgContext == "INPUT_REQUEST") {
      var item = {
        action: "talk",
        text: payload.channelMessage.text,
        bargeIn: options.bargeIn,
        loop: options.loop
      };
      if (options.voiceName) {
        item.voiceName = options.voiceName;
      }
      ncco.push(item);

      var item = {
        action: "input",
        submitOnHash: options.submitOnHash,
        timeOut: options.timeOut,
        eventUrl: [
          callbackUri + "?action=response&to=" + threadId + "&from=" + userId + "&direction=" + direction
        ],
        eventMethod: "POST"
      };

      if (options.maxDigits) {
        item.maxDigits = options.maxDigits;
      }

      ncco.push(item);
    } else {
      // Answers never loop more than once, it could cause problems.
      var item = {
        action: "talk",
        text: payload.channelMessage.text,
        loop: 1
      };
      if (options.voiceName) {
        item.voiceName = options.voiceName;
      }
      ncco.push(item);
    }

    if (msgContext == "COMMENT") {
      // This is a comment, store it in plugin data and send it in batch.

      //Utils.setPluginLocalData(body.caller, "conversation", "ncco", ncco);
      channelSetting.runtimeCTX.ncco = ncco;

      var response = new OutboundResponse();

      response.setHTTPResponse(null);
      //response.setChannelSetting(channelSetting);
      response.channelSetting = channelSetting;

      app.send(Status.SUCCESS, response);
      return;
    }
  }

  var response = new OutboundResponse();
  response.setHTTPResponse({
    headers: {
      "Content-Type": "application/json"
    },
    httpStatus: 200,
    body: JSON.stringify(ncco),
  });

  app.send(Status.SUCCESS, response);

}

module.exports = {
  onMessageInbound: onMessageInbound,
  onMessageOutbound: onMessageOutbound
}

function deleteConferenceCallLocalData(body, inbound) {

  if (inbound.runtime.conference) {

    // Gets the code and moderator code from inbound
    var split = inbound.runtime.conference.split("/");
    if (split.length == 2) {
      var code = split[0];
      if (code && code != "0") {
        // Delete the local data linked to the code
        Utils.setPluginLocalData(body.caller, "provider", "conference-" + code, null);
      }

      var moderatorCode = split[1];
      if (moderatorCode && moderatorCode != "0") {
        // Delete the local data linked to the moderator code
        Utils.setPluginLocalData(body.caller, "provider", "conference-" + moderatorCode, null);
      }
    }
  }
}

function handleEventInbound(app, body) {

  if (body.payload.bodyData && body.payload.bodyData.status) {
    var eventType = body.payload.bodyData.status;

    var inbound = getInboundPayloadData(body.payload, false);
    var registrationData = body.payload.registrationData;

    switch (eventType) {
      case "started":
      case "ringing":
      case "answered":
      case "machine":
      case "completed":
      case "timeout":
      case "failed":
      case "rejected":
      case "cancelled":
      case "busy":

        if (registrationData.events) {
          var eventData = registrationData.events[eventType];
          if (eventData && eventData.intent) {

            if (!inbound.data.from) {
              inbound.data.from = "unknown";
            }
            if (!inbound.data.to) {
              inbound.data.to = "unknown";
            }

            var output = new InboundOutput();

            output.setUserId(inbound.data.from);
            output.setThreadId(inbound.data.to);
            output.setData(inbound.data);
            output.setRuntimeCTX(inbound.runtime);
            output.setSync(false);
            output.setUserInfo({
              email: "nexmo-" + inbound.data.from + "@cnv.ai",
              firstName: inbound.data.from,
              phoneNumber: inbound.data.from
            });

            var conversationMessage = new Message.Conversation();

            conversationMessage.setIntent(eventData.intent, true);
            conversationMessage.setEntityData(eventData.entities);
            conversationMessage.setRuntimeCTX(inbound.runtime.bodyData);
            output.setMessage(conversationMessage);

            var response = new AsyncInboundResponse();
            response.addOutput(output);
            response.setHTTPResponse({
              httpStatus: 200,
              body: "ok",
            });
            app.send(Status.SUCCESS, response);

            return;
          }
        }
        break;
      default:
        console.error("onMessageInbound action 'event':'" + eventType + "' : " + JSON.stringify(body.payload.bodyData));
        break;
    }
  }

  var response = new OutboundResponse();
  response.setHTTPResponse({
    httpStatus: 200,
    body: "ok",
  });

  app.send(Status.SUCCESS, response);

}

function getSMSInboundPayloadData(payload) {

  var from = null;
  var to = null;
  var messageId = null;
  var conversationUUID = null;
  var keywords = null;
  var timestamp = null;
  var message = null;
  var type = null;

  if (payload.queryParam) {
    if (payload.queryParam.keyword) {
      keywords = payload.queryParam.keyword.data;
    }
    if (payload.queryParam["message-timestamp"]) {
      timestamp = payload.queryParam["message-timestamp"].data[0];
    }
    if (payload.queryParam.messageId) {
      messageId = payload.queryParam.messageId.data[0];
    }
    if (payload.queryParam.msisdn) {
      from = payload.queryParam.msisdn.data[0];
    }
    if (payload.queryParam.text) {
      message = payload.queryParam.text.data[0];
    }
    if (payload.queryParam.to) {
      to = payload.queryParam.to.data[0];
    }
    if (payload.queryParam.type) {
      type = payload.queryParam.type.data[0];
    }
  }

  return {
    data: {
      from: from,
      to: to,
      messageId: messageId,
    },
    runtime: {
      keywords: keywords,
      timestamp: timestamp,
      message: message,
      type: type,
      isVoice: false,
    }
  }
}

function getInboundPayloadData(payload, newInbound) {

  var from = null;
  var to = null;
  var conId = null;
  var dtmf = null;
  var intent = null;
  var entities = null;
  var direction = null;
  var conversationUUID = null;
  var recordingFormat = null;
  var conferenceCode = null;

  if (payload.queryParam) {
    if (payload.queryParam.from) {
      from = payload.queryParam.from.data[0];
    }
    if (payload.queryParam.to) {
      to = payload.queryParam.to.data[0];
    }
    if (payload.queryParam.conversation_uuid) {
      conId = payload.queryParam.conversation_uuid.data[0];
    }
    if (payload.queryParam.conversationUUID) {
      conversationUUID = payload.queryParam.conversationUUID.data[0];
    }
    if (payload.queryParam.dtmf) {
      dtmf = payload.queryParam.dtmf.data[0];
    }
    if (payload.queryParam.recording_format) {
      recordingFormat = payload.queryParam.recording_format.data[0];
    }
    if (payload.queryParam.conference) {
      conferenceCode = payload.queryParam.conference.data[0];
    }
    if (!newInbound) {
      if (payload.queryParam.intent) {
        intent = payload.queryParam.intent.data[0];
      }
      if (payload.queryParam.entities) {
        entities = payload.queryParam.entities.data[0];
      }
      if (payload.queryParam.direction) {
        direction = payload.queryParam.direction.data[0];
      }
    }
  }

  if (payload.bodyData) {
    if (!from) {
      from = payload.bodyData.from;
    }
    if (!to) {
      to = payload.bodyData.to;
    }
    if (!conId) {
      conId = payload.bodyData.conversation_uuid;
    }
    if (!dtmf) {
      dtmf = payload.bodyData.dtmf;
    }
    if (!recordingFormat) {
      recordingFormat = payload.bodyData.recording_format;
    }
    if (!newInbound) {
      if (!intent) {
        intent = payload.bodyData.intent;
      }
      if (!entities) {
        entities = payload.bodyData.entities;
      }
      if (!direction) {
        direction = payload.bodyData.direction;
      }
    }
  }

  if (!direction) {
    direction = "inbound";
  }

  if (conId && (!from || from == "anonymous")) {
    from = conId;
  }

  if (newInbound) {
    intent = null;
    entities = null;

    // If this is a new inbound we need template and entities from plugin reg
    var registrationData = payload.registrationData;

    if (registrationData.inbound) {

      var defaultTemplate = registrationData.inbound.default;
      if (defaultTemplate && defaultTemplate.intent) {
        intent = defaultTemplate.intent;
        entities = defaultTemplate.entities;
      }

      var numbers = registrationData.inbound.numbers;
      if (numbers) {
        for (var i = 0; i < numbers.length; i++) {
          var number = numbers[i];
          if (number.msisdn == to) {
            if (number.intent) {
              intent = number.intent;
              // we null this so we don't get the default templates entities values
              entities = null;
            }
            if (number.entities) {
              // We do this seperatly from checking for intent so we can have
              // each number set entities on default template
              entities = number.entities;
            }
            break;
          }
        }
      }
    }

  } else {
    if (entities) {
      // Any entities sent with url will be base64 encoded,
      // we need to decode them back to map
      entities = Buffer.from(entities, 'base64');
      if (entities) {
        entities = JSON.parse(entities);
      }
    }
  }

  return {
    data: {
      from: from,
      to: to,
      conversationId: conId,
    },
    runtime: {
      recording: false,
      dtmf: dtmf,
      intent: intent,
      entities: entities,
      direction: direction,
      bodyData: payload.bodyData,
      conversationUUID: conversationUUID,
      recordingFormat: recordingFormat,
      conference: conferenceCode,
      isVoice: true,
    }
  }
}